import { Elysia, ValidationError, getSchemaValidator } from 'elysia';
import { SignJWT, jwtVerify } from 'jose';
import { Type as t } from '@sinclair/typebox';
export const jwt = ({ name = 'jwt', secret, alg = 'HS256', crit, schema, nbf, exp, ...payload }) => {
    if (!secret)
        throw new Error("Secret can't be empty");
    const key = typeof secret === 'string' ? new TextEncoder().encode(secret) : secret;
    const validator = schema
        ? getSchemaValidator(t.Intersect([
            schema,
            t.Object({
                iss: t.Optional(t.String()),
                sub: t.Optional(t.String()),
                aud: t.Optional(t.Union([t.String(), t.Array(t.String())])),
                jti: t.Optional(t.String()),
                nbf: t.Optional(t.Union([t.String(), t.Number()])),
                exp: t.Optional(t.Union([t.String(), t.Number()])),
                iat: t.Optional(t.String())
            })
        ]), {})
        : undefined;
    return new Elysia({
        name: '@elysiajs/jwt',
        seed: {
            name,
            secret,
            alg,
            crit,
            schema,
            nbf,
            exp,
            ...payload
        }
    }).decorate(name, {
        sign: (morePayload) => {
            let jwt = new SignJWT({
                ...payload,
                ...morePayload,
                nbf: undefined,
                exp: undefined
            }).setProtectedHeader({
                alg,
                crit
            });
            if (nbf)
                jwt = jwt.setNotBefore(nbf);
            if (exp)
                jwt = jwt.setExpirationTime(exp);
            return jwt.sign(key);
        },
        verify: async (jwt) => {
            if (!jwt)
                return false;
            try {
                const data = (await jwtVerify(jwt, key)).payload;
                if (validator && !validator.Check(data))
                    throw new ValidationError('JWT', validator, data);
                return data;
            }
            catch (_) {
                return false;
            }
        }
    });
};
export default jwt;
