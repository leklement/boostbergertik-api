"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jwt = void 0;
const elysia_1 = require("elysia");
const jose_1 = require("jose");
const typebox_1 = require("@sinclair/typebox");
const jwt = ({ name = 'jwt', secret, alg = 'HS256', crit, schema, nbf, exp, ...payload }) => {
    if (!secret)
        throw new Error("Secret can't be empty");
    const key = typeof secret === 'string' ? new TextEncoder().encode(secret) : secret;
    const validator = schema
        ? (0, elysia_1.getSchemaValidator)(typebox_1.Type.Intersect([
            schema,
            typebox_1.Type.Object({
                iss: typebox_1.Type.Optional(typebox_1.Type.String()),
                sub: typebox_1.Type.Optional(typebox_1.Type.String()),
                aud: typebox_1.Type.Optional(typebox_1.Type.Union([typebox_1.Type.String(), typebox_1.Type.Array(typebox_1.Type.String())])),
                jti: typebox_1.Type.Optional(typebox_1.Type.String()),
                nbf: typebox_1.Type.Optional(typebox_1.Type.Union([typebox_1.Type.String(), typebox_1.Type.Number()])),
                exp: typebox_1.Type.Optional(typebox_1.Type.Union([typebox_1.Type.String(), typebox_1.Type.Number()])),
                iat: typebox_1.Type.Optional(typebox_1.Type.String())
            })
        ]), {})
        : undefined;
    return new elysia_1.Elysia({
        name: '@elysiajs/jwt',
        seed: {
            name,
            secret,
            alg,
            crit,
            schema,
            nbf,
            exp,
            ...payload
        }
    }).decorate(name, {
        sign: (morePayload) => {
            let jwt = new jose_1.SignJWT({
                ...payload,
                ...morePayload,
                nbf: undefined,
                exp: undefined
            }).setProtectedHeader({
                alg,
                crit
            });
            if (nbf)
                jwt = jwt.setNotBefore(nbf);
            if (exp)
                jwt = jwt.setExpirationTime(exp);
            return jwt.sign(key);
        },
        verify: async (jwt) => {
            if (!jwt)
                return false;
            try {
                const data = (await (0, jose_1.jwtVerify)(jwt, key)).payload;
                if (validator && !validator.Check(data))
                    throw new elysia_1.ValidationError('JWT', validator, data);
                return data;
            }
            catch (_) {
                return false;
            }
        }
    });
};
exports.jwt = jwt;
exports.default = exports.jwt;
